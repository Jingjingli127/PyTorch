# PyTorch模型定义

## `nn.Module`--the main building block

- 所有神经网络的基类（要继承的类）--`torch.nn`模块下的`nn.Module`
- 模型定义应包括两个主要部分：各部分的初始化`__init__`,数据流向定义`forward` 
  - `forward(self,x)`：接收Variable of input data，**必须**返回Variable of output data
  - 可以使用`Modules` defined in constructor和arbitrary operators on variables

## Custom Module Use case:

> 官网：In general, it is recommended to **define a custom module for anything beyond the simplest use cases**, as this gives full flexibility on how submodules are used for a module’s computation.

- Module可以contain other Modules-->使用Sequential, ModuleList, ModuleDict定义的模块(**useful building blocks** for developing more elaborate functionality)

## Sequential--direct list

- 对应`nn.Sequential()`模块

- <u>使用场景</u>：当模型的前向计算为**简单串联(in-order chaining of modules)**各个层的计算时，且只有**single input and output**
- <u>优点</u>：简单、易读、不需要再写forward（因为顺序已经定义好了）
- <u>缺点</u>：使模型定义丧失灵活性，不能在模型中间加入外部输入

- <u>接收</u>：1. 有序字典[OrderedDict1 ](https://realpython.com/python-ordereddict/)[OrderedDict2](https://www.geeksforgeeks.org/ordereddict-in-python/)（dict subclass that **remembers the order** entries were added）2.一系列子模块作为参数来逐一添加Module的实例
- <u>前向计算</u>：按实例的添加顺序逐一计算

- 结合`Sequential`定义的方式理解：

```python
class MySequential(nn.Module):
    from collections import OrderedDict
    def __init__(self, *args):
        super(MySequential, self).__init__()
        if len(args) == 1 and isinstance(args[0], OrderedDict): # 如果传入的是一个OrderedDict
            for key, module in args[0].items():
                self.add_module(key, module)  # add_module方法会将module添加进self._modules(一个OrderedDict)
        else:  # 传入的是一些Module
            for idx, module in enumerate(args):
                self.add_module(str(idx), module)
    def forward(self, input):
        # self._modules返回一个 OrderedDict，保证会按照成员添加时的顺序遍历成
        for module in self._modules.values():
            input = module(input)
        return input
```

- **使用**Sequential定义模块：将模型的层按顺序排列起来

```python
# 1.直接排列
import torch.nn as nn
net = nn.Sequential(
        nn.Linear(784, 256),
        nn.ReLU(),
        nn.Linear(256, 10), 
        )
print(net)

# 2.使用OrderedDict--可以添加层名！
import collections
import torch.nn as nn
net2 = nn.Sequential(collections.OrderedDict([
          ('fc1', nn.Linear(784, 256)),
          ('relu1', nn.ReLU()),
          ('fc2', nn.Linear(256, 10))
          ]))
print(net2)
```



## ModuleList

- 对应`nn.ModuleList()`模块

- 接收：子模块/层的列表--继承于`nn.Module`类
  - 也可以使用list的`append`和`extend`方法操作
- 使用：

```python
net = nn.ModuleList([nn.Linear(784, 256), nn.ReLU()])
net.append(nn.Linear(256, 10)) # # 类似List的append操作
print(net[-1])  # 类似List的索引访问
print(net)
```

- 注：`nn.ModuleList()`**并没有定义网络**，只是将不同的模块存储在一起；ModuleList元素的先后顺序并不代表其在网络中的真实位置顺序，**需要定义**`forward`函数指定各个层的先后顺序才算完成了模型的定义（与Sequential不同）

```python
# 模板：
class model(nn.Module):
  def __init__(self, ...):
    super().__init__()
    self.modulelist = ...
    ...
    
  def forward(self, x): #使用for循环即可完成
    for layer in self.modulelist:
      x = layer(x)
    return x


# 例子：
class Net3(nn.Module):
  def __init__(self, ...):
    super().__init__()
    self.modulelist = nn.ModuleList([nn.Linear(784, 256), nn.ReLU()])
    self.modulelist.append(nn.Linear(256, 10))
    
  def forward(self, x):
    for layer in self.modulelist:
      x = layer(x)
    return x

net3_ = Net3()
output = net3_(input)
```

## ModuleDict

- 对应`nn.ModuleDict()`模块
- 与Sequential+OrderedDict定义类似：可以指定层名称

```python
net = nn.ModuleDict({
    'linear': nn.Linear(784, 256),
    'act': nn.ReLU(),
})
net['output'] = nn.Linear(256, 10) # 添加
print(net['linear']) # 字典形式访问
print(net.output) # pytorch形式访问
print(net)

```

- 注：同样没有定义网络！只是将不同模块储存在一起
  - 此时如果要定义模型--不能是简单的for循环，需要对每个key循环或hard-coded每一层

```python
class Net3(nn.Module):
    def __init__(self, ...):
        super().__init__()
        self.net = nn.ModuleDict({
        'linear': nn.Linear(784, 256),
        'act': nn.ReLU(),
    })
        self.net['output'] = nn.Linear(256, 10) # 添加
    
    def forward(self, x):
        for key in self.net:
            x = self.net[key](x)
        return x
```

















